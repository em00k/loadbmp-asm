# file opened: loadbmp-nonfu.asm
  1   0000              ; load a bmp 256 indexed image that is stored upside down
  2   0000              ; It uses a small memory footprint between $2000 - $3FFF
  3   0000              ; Image needs to be 256*192 256 colours with the Next uniform palette.
  4   0000              ; em00k2020 / David Saphier 23/09/20
  5   0000
  6   0000              	;device zxspectrumnext
  7   0000              	device zxspectrum48						; we will use a sna for the example
  8   0000              	CSPECTMAP loadbmp_test.map
  9   0000              	include "macros.asm"					; contains out nextreg macros
# file opened: macros.asm
  1+  0000              M_GETSETDRV 	equ $89
  2+  0000              F_OPEN 			equ $9a
  3+  0000              F_CLOSE 		equ $9b
  4+  0000              F_READ 			equ $9d
  5+  0000              F_WRITE 		equ $9e
  6+  0000              F_SEEK 			equ $9f
  7+  0000              F_GET_DIR 		equ $a8
  8+  0000              F_SET_DIR 		equ $a9
  9+  0000
 10+  0000              FA_READ 		equ $01
 11+  0000              FA_APPEND 		equ $06
 12+  0000              FA_OVERWRITE 	equ $0C
 13+  0000
 14+  0000              	macro ESXDOS command
 15+  0000 ~            		rst 8
 16+  0000 ~            		db command
 17+  0000              	endm
 18+  0000
 19+  0000              	macro loadfile name, dest, size, offset
 20+  0000 ~            		ld ix,name
 21+  0000 ~            		ld hl,dest
 22+  0000 ~            		ld bc,size
 23+  0000 ~            		ld de,offset
 24+  0000 ~            		call load
 25+  0000              	endm
 26+  0000
 27+  0000              	macro nextreg_a reg
 28+  0000 ~            		dw $92ed
 29+  0000 ~            		db reg
 30+  0000              	endm
 31+  0000
 32+  0000              	macro mirror_a
 32+  0000 ~              dw $24ed
 32+  0000                endm
 33+  0000
 34+  0000              	macro nextreg_nn reg, value
 35+  0000 ~            		dw $91ed
 36+  0000 ~            		db reg
 37+  0000 ~            		db value
 38+  0000              	endm
 39+  0000
 40+  0000              	macro break
 41+  0000 ~            		dw $01dd
 42+  0000              	endm
# file closed: macros.asm
 10   0000
 11   0000              mystack 	equ $7ffe						; so we know where stack is
 12   0000              startoffset equ 1078+16384+16384+8192		; startpos in bmp file, read from LAST 8kb, skip header. bmp must be 256 indexed
 13   0000              startbank 	equ 32
 14   0000
 15   0000              	org $8000								; start at $8000 / 32768
 16   8000
 17   8000              ; ------------------------------------
 18   8000              ; main program
 19   8000
 20   8000              main_prog:
 21   8000 F3           			di 								; di so ints dont trigger when we've paged out ROM
 22   8001 31 FE 7F     			ld sp,mystack 					; just for saftey
 23   8004 CD 84 80     			call clearula					; clear ula to black
 24   8007 CD 68 80     			call setregisters 				; set relevant nregs
 25   800A
 26   800A              			;load the bmp in 8kb chunks
 27   800A
 28   800A 06 07        			ld b,7							; we want to loop 8 times (8kb*8 = 48kb)
 29   800C 3A 92 80     			ld a,(L2bank)
 30   800F 4F           			ld c,a 							; store start bank in c
 31   8010              loadloop:
 32   8010
 33   8010 79           			ld a,c							; get the bank in c and put in a
 34   8011              			nextreg_a $52					; set mmu slot 1 to bank L2bank ($2000-3fff)
 34   8011 ED 92       >		dw $92ed
 34   8013 52          >		db $52
 35   8014 0C           			inc c							; inc our bank
 36   8015 C5           			push bc 						; save bc so we can use again
 37   8016
 38   8016
 39   8016 DD 21 E5 80  			ld ix,bmpfilename				; point ix to our filename
 40   801A 21 00 40     			ld hl,$4000						; destination address $2000
 41   801D 01 00 20     			ld bc,$2000						; amount of data to load $2000
 42   8020 ED 5B 93 80  			ld de,(L2offsetpos)				; offset inside the bmp file we want to load, we start at the last 8kb
 43   8024 CD 95 80     			call load 						; call esxdos routine to load 8kbchunk
 44   8027 CD 49 80     			call flip_layer2lines			; flip the 32 lines of layer 2
 45   802A
 46   802A 2A 93 80     			ld hl,(L2offsetpos)				; lets decrease our offset, put offset into hl
 47   802D 11 00 20     			ld de,$2000						; set de to 8kb
 48   8030 ED 52        			sbc hl,de						; subtract de from hl
 49   8032 22 93 80     			ld (L2offsetpos),hl 			; store the value in (L2offsetpos)
 50   8035
 51   8035 C1           			pop bc 							; pop back our loop in b and c our bank
 52   8036
 53   8036 10 D8        			djnz loadloop					; if b > 0 then loop
 54   8038
 55   8038 21 36 A4     			ld hl,startoffset				; reset our offset incase we want to call this again
 56   803B 22 93 80     			ld (L2offsetpos),hl 			; reset the l2offsetpos
 57   803E
 58   803E              			nextreg_nn $69,%10000000		; enable layer 2
 58   803E ED 91       >		dw $91ed
 58   8040 69          >		db $69
 58   8041 80          >		db %10000000
 59   8042              			nextreg_nn $51,$ff				; return ROM to slot 1
 59   8042 ED 91       >		dw $91ed
 59   8044 51          >		db $51
 59   8045 FF          >		db $ff
 60   8046
 61   8046              image_loop:
 62   8046
 63   8046              			; end program
 64   8046
 65   8046 C3 46 80     			jp image_loop
 66   8049
 67   8049              flip_layer2lines:
 68   8049
 69   8049              			; $2000 - $3fff Layer2 BMP data loaded
 70   8049              			; the data is upside down so we need to flip line 0 - 32
 71   8049              			; hl = top line first left pixel, de = bottom line, first left pixel
 72   8049 21 00 40     			ld hl,$4000
 72   804C 11 00 5F       ld de,$5f00
 72   804F 01 00 10       ld bc,$1000
 73   8052
 74   8052              .copyloop:
 75   8052 7E           			ld a,(hl)						; hl is the top lines, get the value into a
 76   8053 08           			ex af,af'						; swap to shadow a reg
 77   8054 1A           			ld a,(de)						; de is bottom lines, get value in a
 78   8055 77           			ld (hl),a						; put this value into hl
 79   8056 08           			ex af,af'						; swap back shadow reg
 80   8057 12           			ld (de),a 						; put the value into de
 81   8058 23           			inc hl							; inc hl to next byte
 82   8059 1C           			inc e							; only inc e as we have to go left to right then up with d
 83   805A 7B           			ld a,e							; check e has >255
 84   805B B7           			or a
 85   805C CC 66 80     			call z,.decd						; it did do we need to dec d
 86   805F 0B           			dec bc							; dec bc for our loop
 87   8060 78           			ld a,b							; has bc = 0 ?
 88   8061 B1           			or c
 89   8062 C2 52 80     			jp nz,.copyloop					; no carry on until it does
 90   8065 C9           			ret
 91   8066              .decd:
 92   8066 15           			dec d 							; this decreases d to move a line up
 93   8067 C9           			ret
 94   8068
 95   8068              setregisters:
 96   8068
 97   8068              			nextreg_nn $8,%11111010
 97   8068 ED 91       >		dw $91ed
 97   806A 08          >		db $8
 97   806B FA          >		db %11111010
 98   806C              			nextreg_nn $15,%00010000		; set USL layer order
 98   806C ED 91       >		dw $91ed
 98   806E 15          >		db $15
 98   806F 10          >		db %00010000
 99   8070              			nextreg_nn $12,16				; set base bank for Layer 2 (in 16kb mode)
 99   8070 ED 91       >		dw $91ed
 99   8072 12          >		db $12
 99   8073 10          >		db 16
100   8074              			nextreg_nn $69,%00000000		; display control reg, 0 L2 off, set to %10000000 to show draw
100   8074 ED 91       >		dw $91ed
100   8076 69          >		db $69
100   8077 00          >		db %00000000
101   8078              			nextreg_nn $7,3					; cpu speed 28, set to 0 to see in slow,
101   8078 ED 91       >		dw $91ed
101   807A 07          >		db $7
101   807B 03          >		db 3
102   807C              			nextreg_nn $14,0				; global transparency set to palette 0 = black
102   807C ED 91       >		dw $91ed
102   807E 14          >		db $14
102   807F 00          >		db 0
103   8080 AF           			xor a
103   8081 D3 FE          out ($fe),a				; border black
104   8083 C9           			ret
105   8084
106   8084              clearula:
107   8084 21 00 58     			ld hl,22528
108   8087 11 01 58     			ld de,22529
109   808A 36 00        			ld (hl),0
110   808C 01 00 03     			ld bc,768
111   808F ED B0        			ldir
112   8091 C9           			ret
113   8092
114   8092              ; ------------------------------------
115   8092              ; data / includes
116   8092
117   8092              L2bank:
118   8092 20           			db 32						; this is 16kb bank 16 we set with ref $12
119   8093              L2offsetpos
120   8093 36 A4        			dw 1078+16384+16384+8192	; this points to the last 8kb of the bmp file
121   8095
122   8095              			include "esxdos.asm" 		; this contains the load subroutines
# file opened: esxdos.asm
  1+  8095
  2+  8095              load:
  3+  8095
  4+  8095 E5           	push hl  					; save destination
  5+  8096 C5           	push bc 					; save size
  6+  8097 D5           	push de
  7+  8098 3E 2A        	ld a, '*' 					; use current drive
  8+  809A 06 01        	ld b, FA_READ 				; set mode
  9+  809C
 10+  809C              	ESXDOS F_OPEN
 10+  809C CF          >		rst 8
 10+  809D 9A          >		db F_OPEN
 11+  809E DA BC 80     	jp c,failedtoload    		; jp to failed if failed to open
 12+  80A1
 13+  80A1 32 E4 80     	ld (handle), a 				; store handle
 14+  80A4
 15+  80A4 D1           	pop de
 16+  80A5
 17+  80A5 DD 21 01 00  	ld ix, 1 					; seek from start of file
 18+  80A9 01 00 00     	ld bc, 0
 19+  80AC
 20+  80AC              	ESXDOS F_SEEK
 20+  80AC CF          >		rst 8
 20+  80AD 9F          >		db F_SEEK
 21+  80AE
 22+  80AE 3A E4 80     	ld a, (handle) 				; restore handle
 23+  80B1
 24+  80B1 C1           	pop bc 						; read length
 25+  80B2 DD E1        	pop ix 						; memory dest
 26+  80B4
 27+  80B4              	ESXDOS F_READ
 27+  80B4 CF          >		rst 8
 27+  80B5 9D          >		db F_READ
 28+  80B6
 29+  80B6 3A E4 80     	ld a, (handle)
 30+  80B9              	ESXDOS F_CLOSE 			; close file
 30+  80B9 CF          >		rst 8
 30+  80BA 9B          >		db F_CLOSE
 31+  80BB
 32+  80BB C9           	ret
 33+  80BC
 34+  80BC              failedtoload:
 35+  80BC
 36+  80BC 21 D2 80     	ld hl,failedtoloadtext
 36+  80BF CD CA 80       call printrstfailed
 37+  80C2 DD E5        	push ix
 37+  80C4 E1             pop hl
 37+  80C5 CD CA 80       call printrstfailed
 38+  80C8 F3           	di
 38+  80C9 76             halt
 39+  80CA
 40+  80CA              printrstfailed;
 41+  80CA 7E           	ld a,(hl)
 41+  80CB B7             or a
 41+  80CC C8             ret z
 41+  80CD D7             rst 16
 41+  80CE 23             inc hl
 41+  80CF C3 CA 80       jp printrstfailed
 42+  80D2
 43+  80D2              failedtoloadtext:
 44+  80D2 46 61 69 6C  	db "Failed to load : ",0
 44+  80D6 65 64 20 74
 44+  80DA 6F 20 6C 6F
 44+  80DE 61 64 20 3A
 44+  80E2 20 00
 45+  80E4
 46+  80E4
 47+  80E4 00           handle: db 0
 48+  80E5
 49+  80E5
# file closed: esxdos.asm
123   80E5
124   80E5              bmpfilename:
125   80E5 31 2E 62 6D  			db "1.bmp",0				; image file
125   80E9 70 00
126   80EB
127   80EB
128   80EB              	savesna "H:\bmptest\bmptest.snx",main_prog
129   80EB
130   80EB
# file closed: loadbmp-nonfu.asm
